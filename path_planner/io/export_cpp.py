"""
Export paths to C++ code for shulib.

Generates ready-to-use autonomous routines that integrate with
your existing motion functions (moveToPose, moveVertical, rotateTo).
"""

import math
from datetime import datetime
from typing import Optional
from path_planner.core.models import Path, Waypoint, MotionType, HeadingMode
from path_planner.core.commands import Command
from path_planner.core.coordinates import calculate_heading


def export_path_to_cpp(
    path: Path,
    commands: dict[str, Command],
    include_header: bool = True,
    namespace: Optional[str] = "shulib::seasons::pushback::auton::generated"
) -> str:
    """
    Generate C++ code for a single path.
    
    Args:
        path: The path to export
        commands: Dict of command_id -> Command for code generation
        include_header: Whether to include file header comment
        namespace: C++ namespace (None for no namespace)
    
    Returns:
        C++ code as a string
    """
    lines = []
    
    if include_header:
        lines.extend(_generate_header(path))
        lines.append("")
    
    lines.extend([
        '#pragma once',
        '',
        '#include "shulib/core/chassis.hpp"',
        '#include "shulib/core/pose.hpp"',
        '#include "shulib/seasons/pushback_2026/mechanisms.hpp"',
        '#include "shulib/seasons/pushback_2026/auton.hpp"',
        '#include "pros/rtos.hpp"',
        '',
    ])
    
    if namespace:
        lines.append(f'namespace {namespace} {{')
        lines.append('')
    
    lines.extend(_generate_function(path, commands))
    
    if namespace:
        lines.append('')
        lines.append(f'}} // namespace {namespace}')
    
    return '\n'.join(lines)


def export_function_only(path: Path, commands: dict[str, Command]) -> str:
    """Export just the function body (for copy/paste into existing file)."""
    return '\n'.join(_generate_function(path, commands))


def _generate_header(path: Path) -> list[str]:
    """Generate file header comment."""
    return [
        '// ' + '=' * 75,
        '// AUTO-GENERATED BY SHULIB PATH PLANNER v1.0.0',
        '//',
        f'// Path:      {path.name}',
        f'// Alliance:  {path.alliance.value.title()}',
        f'// Side:      {path.side.value.title()}',
        f'// Waypoints: {len(path.waypoints)}',
        f'// Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}',
        '//',
        '// DO NOT EDIT - Regenerate from path_planner if changes needed',
        '// ' + '=' * 75,
    ]


def _path_name_to_function(name: str) -> str:
    """Convert path name to valid C++ function name."""
    words = name.replace('-', ' ').replace('_', ' ').split()
    if not words:
        return "generatedAuto"
    
    result = words[0].lower()
    for word in words[1:]:
        result += word.capitalize()
    
    result = ''.join(c for c in result if c.isalnum() or c == '_')
    return result or "generatedAuto"


def _generate_function(path: Path, commands: dict[str, Command]) -> list[str]:
    """Generate the complete function."""
    lines = []
    func_name = _path_name_to_function(path.name)
    
    lines.append(f'void {func_name}(Chassis& chassis, Mechanisms& mech) {{')
    
    waypoints = path.waypoints
    if not waypoints:
        lines.append('    // No waypoints defined')
        lines.append('}')
        return lines
    
    for i, wp in enumerate(waypoints):
        lines.append(f'    // ─── Waypoint {i + 1} {"(Start)" if i == 0 else ""} ───')
        
        # Calculate heading
        heading = _get_heading(wp, waypoints, i)
        heading_str = f"{heading:.1f}" if heading is not None else "0.0"
        
        lines.append(f'    // Position: ({wp.x:.1f}, {wp.y:.1f}), Heading: {heading_str}°')
        
        # Generate motion code
        if wp.motion_type == MotionType.START:
            lines.append(f'    chassis.setPose({wp.x:.1f}, {wp.y:.1f}, {heading_str});')
        
        elif wp.motion_type == MotionType.MOVE_TO_POSE:
            reverse = "true" if wp.reverse else "false"
            intaking = "true" if wp.intaking else "false"
            conveyor = "true" if wp.conveyor else "false"
            lines.append(f'    moveToPose(chassis, Pose({wp.x:.1f}, {wp.y:.1f}, {heading_str}), &mech, {reverse}, {intaking}, {conveyor});')
        
        elif wp.motion_type == MotionType.MOVE_VERTICAL:
            if i > 0:
                prev = waypoints[i - 1]
                distance = math.sqrt((wp.x - prev.x)**2 + (wp.y - prev.y)**2)
                if wp.reverse:
                    distance = -distance
                intaking = "true" if wp.intaking else "false"
                conveyor = "true" if wp.conveyor else "false"
                lines.append(f'    moveVertical(chassis, {distance:.1f}, &mech, {intaking}, {conveyor});')
        
        elif wp.motion_type == MotionType.ROTATE_TO:
            lines.append(f'    rotateTo(chassis, {heading_str});')
        
        # Generate commands after arrival
        if wp.commands_after:
            lines.append('    // Commands:')
            for cmd_id in wp.commands_after:
                if cmd_id in commands:
                    code = commands[cmd_id].generate_code()
                    for code_line in code.split('\n'):
                        lines.append(f'    {code_line}')
        
        lines.append('')
    
    lines.append('}')
    return lines


def _get_heading(wp: Waypoint, waypoints: list[Waypoint], index: int) -> Optional[float]:
    """Calculate heading for a waypoint."""
    if wp.heading_mode == HeadingMode.MANUAL and wp.heading is not None:
        return wp.heading
    
    # Auto: calculate from direction to next waypoint
    if index < len(waypoints) - 1:
        next_wp = waypoints[index + 1]
        return calculate_heading(wp.x, wp.y, next_wp.x, next_wp.y)
    
    # Last waypoint: use direction from previous
    if index > 0:
        prev_wp = waypoints[index - 1]
        return calculate_heading(prev_wp.x, prev_wp.y, wp.x, wp.y)
    
    return 0.0